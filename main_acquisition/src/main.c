/*
Author:	  laplace
File:     main.c
Info:     Generated by Atollic TrueSTUDIO(R) 9.0.1   2018-06-30

*/

/* Includes */
#include "stm32f4xx.h"
#include "stm32f4_discovery.h"
#include <stdio.h>
#include <string.h>
#include <math.h>
/* homemade libraries includes */
#include "imu10dof.h"
#include "l3gd20.h"
#include "rf_comm.h"
#include "gps.h"
#include "leds.h"
#include "rocket_packet.h"
#include "sd_card.h"


/* Private macro */

/* Private variables */
// timer counter variable
static __IO uint32_t TIM2_ms_counter;
/* Private function prototypes */
void init_TIM2();
//void enable_TIM2_interrupts();
void TIM2_IRQHandler();
void TIM2_ms_delay_decrement(void);
void delay_ms(__IO uint32_t delay);
void USART3_IRQHANDLER();

/**
**===========================================================================
**
**  Abstract: main program
**
**===========================================================================
*/
int main(void) {

	/**
	*  IMPORTANT NOTE!
	*  The symbol VECT_TAB_SRAM needs to be defined when building the project
	*  if code has been located to RAM and interrupts are used.
	*  Otherwise the interrupt table located in flash will be used.
	*  See also the <system_*.c> file and how the SystemInit() function updates
	*  SCB->VTOR register.
	*  E.g.  SCB->VTOR = 0x20000000;
	*/

	/* Application code goes here */

	// configure Systick to 84000 ticks
	// with 168 000 000 ticks/s it means an interrupt every 0.5 ms
	SysTick_Config(SystemCoreClock / 2000);
	
	// global BMP180, L3GD20 and LSM303 structs are declared here
	BMP180_struct bmp180_data;
	L3GD20_struct l3gd20_data;
	LSM303DLHC_struct lsm303_data;

	init_leds();
	init_TIM2();
	set_led_off(LED1);
	set_led_off(LED2);
	set_led_off(LED3);
	set_led_off(LED4);
	set_led_off(LED5);
	set_led_off(LED6);
	init_rfd900();
	initGps();// activate USART1 on PA9 (TX) and PA10 (RX)

	imu10dof_init((struct BMP180_struct *) &bmp180_data, &delay_ms);
	bmp180_data.delay_func = &delay_ms;


	gpsData gpsDataStruct; //struct used to store GPS data, need to malloc

	// writing test rocket data and packet
	RocketData rd;
	RocketPacket rp;
	rp.start_char = ROCKET_PACKET_START;
	rp.data = rd;
	rp.checksum = 0;

	unsigned int num_bytes;
	uint8_t rp_buffer[ROCKET_PACKET_SIZE];

	sd_card_init();
	double tstamp = 0;

	/* Infinite loop */
	for (;;) {

		// update timestamp
		rp.data.timestamp = tstamp;
		tstamp += 1;

		set_led_on(LED1);
		// update les donn√©es du gps data struct
		updateGps(&gpsDataStruct);
		rp.data.UTCTime = gpsDataStruct.UTCTime;
		if (rp.data.UTCTime < 0 || rp.data.UTCTime > 2.0e+200) {
			rp.data.UTCTime = 0;
		}
		rp.data.latitude = gpsDataStruct.latitude;
		if (rp.data.latitude < 1) {
			rp.data.latitude = 0;
		}
		rp.data.longitude = gpsDataStruct.longitude;
		if (rp.data.longitude < 1) {
			rp.data.longitude = 0;
		}
		rp.data.EWIndicator = gpsDataStruct.EWIndicator;
		if (rp.data.EWIndicator != 'E' || rp.data.EWIndicator != 'W') {
			rp.data.EWIndicator = 'F';
		}
		rp.data.NSIndicator = gpsDataStruct.NSIndicator;
		if (rp.data.NSIndicator != 'N' || rp.data.NSIndicator != 'S') {
			rp.data.NSIndicator = 'M';
		}

		set_led_off(LED1);

		// read IMU10DOF devices
		set_led_on(LED2);
		L3GD20_Read(&l3gd20_data);
		set_led_off(LED2);

		set_led_on(LED3);
		lsm303dlhc_read_acceleration(&lsm303_data);
		lsm303dlhc_read_magneticfield(&lsm303_data);
		lsm303dlhc_read_temperature(&lsm303_data);
		set_led_off(LED3);

		set_led_on(LED4);
		bmp180_start_temperature(&bmp180_data);
		bmp180_read_temperature(&bmp180_data);
		bmp180_start_pressure(&bmp180_data, BMP180_Sampling_lowpower);
		bmp180_read_pressure(&bmp180_data);
		set_led_off(LED4);

		// update rocket packet with imu10dof data
		rp.data.altitude = bmp180_data.altitude;
		rp.data.temperature = bmp180_data.temperature;
		rp.data.pressure = bmp180_data.pressure;
		rp.data.acc_x = lsm303_data.acc_x;
		rp.data.acc_y = lsm303_data.acc_y;
		rp.data.acc_z = lsm303_data.acc_z;
		rp.data.acc_x_uncomp = lsm303_data.acc_x_uncomp;
		rp.data.acc_y_uncomp = lsm303_data.acc_y_uncomp;
		rp.data.acc_z_uncomp = lsm303_data.acc_z_uncomp;
		rp.data.mag_x = lsm303_data.mag_x;
		rp.data.mag_y = lsm303_data.mag_y;
		rp.data.mag_z = lsm303_data.mag_z;
		rp.data.x_gyro = l3gd20_data.X;
		rp.data.y_gyro = l3gd20_data.Y;
		rp.data.z_gyro = l3gd20_data.Z;

		/* write rocket packet to sd card */
		set_led_on(LED5);
		sd_card_write_rocket_data(&(rp.data));
		set_led_off(LED5);

		/* serialize and send packet */
		set_led_on(LED6);
		memset(rp_buffer, 0, ROCKET_PACKET_SIZE);
		num_bytes = serialize_rocket_packet(&rp, rp_buffer);
		rfd900_write(rp_buffer, num_bytes);
		set_led_off(LED6);
    }
}


/* Private functions */

void init_TIM2() {
	// init timer 82 Mhz / 42 -> 0.525 microsecond / tick
	// period = 1950 -> 1 interrupt / ms
	RCC_APB1PeriphClockCmd(RCC_APB1Periph_TIM2, ENABLE);
	TIM_TimeBaseInitTypeDef timerInit;
	timerInit.TIM_Prescaler = 42;
	timerInit.TIM_CounterMode = TIM_CounterMode_Up;
	timerInit.TIM_Period = 1950;
	timerInit.TIM_ClockDivision = TIM_CKD_DIV1;
	timerInit.TIM_RepetitionCounter = 0;
	TIM_TimeBaseInit(TIM2, &timerInit);
	// enable timer
	TIM_Cmd(TIM2, ENABLE);
	// enable timer interrupts
	TIM_ITConfig(TIM2, TIM_IT_Update, ENABLE);

	// init interrupts
	NVIC_InitTypeDef nvic_struct;
	nvic_struct.NVIC_IRQChannel = TIM2_IRQn;
	nvic_struct.NVIC_IRQChannelPreemptionPriority = 0;
	nvic_struct.NVIC_IRQChannelSubPriority = 1;
	nvic_struct.NVIC_IRQChannelCmd = ENABLE;
	NVIC_Init(&nvic_struct);
}

void TIM2_IRQHandler() {
	if (TIM_GetITStatus(TIM2, TIM_IT_Update) != RESET) {
		TIM_ClearITPendingBit(TIM2, TIM_IT_Update);
		// decrement ms count value
		TIM2_ms_delay_decrement();
	}
}

void TIM2_ms_delay_decrement(void) {
	if(TIM2_ms_counter > 0) TIM2_ms_counter--;
}

void delay_ms(__IO uint32_t delay) {
	TIM2_ms_counter = delay;
	while(TIM2_ms_counter) {

	}
}

void USART3_IRQHANDLER() {
//	char byte_rx;
//	if(USART_GetITStatus(RFD_USART_PERIPH_TYPEDEF, USART_IT_RXNE)) {
//		byte_rx = USART_ReceiveData(RFD_USART_PERIPH_TYPEDEF);
//	}
}

/*
 * Callback used by stm32f4_discovery_audio_codec.c.RCC_APB1RCC_AHB1PeriphClockCmd
 * Refer to stm32f4_discovery_audio_codec.h for more info.
 */
void EVAL_AUDIO_TransferComplete_CallBack(uint32_t pBuffer, uint32_t Size){
	/* TODO, implement your code here */
	return;
}

/*
 * Callback used by stm324xg_eval_audio_codec.c.
 * Refer to stm324xg_eval_audio_codec.h for more info.
 */
uint16_t EVAL_AUDIO_GetSampleCallBack(void){
	/* TODO, implement your code here */
	return -1;
}

void init_TIM4() {
	// init timer 82 Mhz / 30147 -> 100003.122 microsecond / tick
	// period = 271 -> 1 interrupt / 100ms
	RCC_APB1PeriphClockCmd(RCC_APB1Periph_TIM4, ENABLE);
	TIM_TimeBaseInitTypeDef timerInit;
	timerInit.TIM_Prescaler = 30147;
	timerInit.TIM_CounterMode = TIM_CounterMode_Up;
	timerInit.TIM_Period = 271;
	timerInit.TIM_ClockDivision = TIM_CKD_DIV1;
	timerInit.TIM_RepetitionCounter = 0;
	TIM_TimeBaseInit(TIM4, &timerInit);
	// enable timer
	TIM_Cmd(TIM4, ENABLE);
	// enable timer interrupts
	TIM_ITConfig(TIM4, TIM_IT_Update, ENABLE);

	// init interrupts
	NVIC_InitTypeDef nvic_struct;
	nvic_struct.NVIC_IRQChannel = TIM4_IRQn;
	nvic_struct.NVIC_IRQChannelPreemptionPriority = 2;
	nvic_struct.NVIC_IRQChannelSubPriority = 2;
	nvic_struct.NVIC_IRQChannelCmd = ENABLE;
	NVIC_Init(&nvic_struct);
}
//trigger every 100 ms
void TIM4_IRQHandler()
{
    // Checks whether the TIM4 interrupt has occurred or not
    if (TIM_GetITStatus(TIM4, TIM_IT_Update))
    {
    	//**************INSERT YOUR CODE HERE*****************



    	//****************************************************
    	// Clears the TIM4 interrupt pending bit
        TIM_ClearITPendingBit(TIM4, TIM_IT_Update);
    }
}

